""" SICKSense Agripollinate LiDAR Detector Version 0.1 
    Created by:    Josiah Faircloth 
    date:    11/11/2025

    Detects and tracks object clusters from SICK TiM561 LiDAR scan data. Reads LiDAR 
    log files generated by LiDAR Logger Version 0.1. Triggers a signal whenever any
    new object appears that was not present before.
"""

import json
import time
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN

# -------------------------------
# Configuration Parameters
# -------------------------------
SCAN_FILE = "lidar_log_11-14-2025_15.47.05.jsonl"  # LiDAR data file 
EPS = 0.25        # DBSCAN cluster distance threshold (meters) - minimum distance between points in a cluster
MIN_SAMPLES = 5   # minimum points per cluster
NEW_OBJ_DIST = 0.25  # meters: if a centroid is this far from all previous, treat as new
OBJECT_MEMORY_TIME = 0.75  # seconds: remember objects for this long after last seen
DISPLAY = True

# -------------------------------
# Event Trigger Function
# -------------------------------
def on_new_object_detected(centroid, timestamp):
    """Called whenever a new cluster appears that wasn't present before."""

    print(f"[ALERT] New object detected at {centroid} at {timestamp:.2f}")

# -------------------------------
# Helper Functions
# -------------------------------
def polar_to_cartesian(ranges):
    """Convert polar ranges to (x, y) coordinates"""
    angles = np.linspace(-45, 225, len(ranges))
    x = ranges * np.cos(np.deg2rad(angles))
    y = ranges * np.sin(np.deg2rad(angles))
    return np.column_stack((x, y))

def detect_objects(points):
    """Cluster points using DBSCAN and return cluster centroids"""
    points = points[~np.isnan(points).any(axis=1)]
    if len(points) < MIN_SAMPLES:
        return []
    db = DBSCAN(eps=EPS, min_samples=MIN_SAMPLES).fit(points)
    labels = db.labels_
    centroids = []
    for lbl in np.unique(labels):
        if lbl == -1:  # noise
            continue
        cluster = points[labels == lbl]
        centroids.append(np.mean(cluster, axis=0))
    return np.array(centroids)


class ObjectTracker:
    """Tracks known objects over time with memory persistence"""
    def __init__(self, memory_time=2.0, distance_threshold=0.4):
        self.known_objects = []  # List of (centroid, last_seen_time)
        self.memory_time = memory_time
        self.distance_threshold = distance_threshold
        self.first_scan = True
    
    def update(self, current_centroids, current_time):
        """Update tracker with new centroids, return list of NEW objects"""
        # On first scan, register all objects but don't trigger
        if self.first_scan:
            for centroid in current_centroids:
                self.known_objects.append((centroid, current_time))
            self.first_scan = False
            return np.array([]).reshape(0, 2)
        
        # Remove old objects that haven't been seen recently
        self.known_objects = [(pos, t) for pos, t in self.known_objects 
                              if current_time - t < self.memory_time]
        
        new_objects = []
        
        for centroid in current_centroids:
            is_new = True
            
            # Check if this centroid matches any known object
            for i, (known_pos, last_time) in enumerate(self.known_objects):
                dist = np.linalg.norm(centroid - known_pos)
                if dist < self.distance_threshold:
                    # Update the position and time of the known object
                    self.known_objects[i] = (centroid, current_time)
                    is_new = False
                    break
            
            if is_new:
                # Actually a new object
                new_objects.append(centroid)
                self.known_objects.append((centroid, current_time))
        
        if new_objects:
            return np.array(new_objects).reshape(-1, 2)
        else:
            return np.array([]).reshape(0, 2)

# -------------------------------
# Main Loop
# -------------------------------
def main():
    tracker = ObjectTracker(memory_time=OBJECT_MEMORY_TIME, distance_threshold=NEW_OBJ_DIST)
    plt.ion()
    fig, ax = plt.subplots(figsize=(10, 10))
    object_count = 0

    with open(SCAN_FILE, 'r') as f:
        for line in f:
            try:
                scan = json.loads(line)
                ranges = np.array(scan["ranges"])
                ranges[(ranges < 0.005) | (ranges > 10)] = np.nan

                points = polar_to_cartesian(ranges)
                centroids = detect_objects(points)
                new_objects = tracker.update(centroids, scan["timestamp"])

                # Trigger event if new objects appear
                for c in new_objects:
                    on_new_object_detected(c, scan["timestamp"])
                    object_count += 1

                # Visualization
                if DISPLAY:
                    ax.clear()
                    ax.scatter(points[:, 0], points[:, 1], s=5, c='gray', label='Scan points')
                    if len(centroids) > 0:
                        ax.scatter(centroids[:, 0], centroids[:, 1], c='blue', s=40, label='Objects')
                    if len(new_objects) > 0:
                        ax.scatter(new_objects[:, 0], new_objects[:, 1], c='red', s=80, label='Detection')
                    ax.set_xlim(-6, 6)
                    ax.set_ylim(-6, 6)
                    ax.set_title("LiDAR Object Detection")
                    ax.legend(loc='upper right')
                    ax.set_aspect('equal')
                    plt.pause(0.01)

                    if len(new_objects) > 0:
                        cont = input("Press Enter to continue...")

                time.sleep(0.05)
            except json.JSONDecodeError:
                continue
            except KeyboardInterrupt:
                break

    plt.ioff()
    plt.show()
    print(f"Total objects detected: {object_count}")

if __name__ == "__main__":
    main()