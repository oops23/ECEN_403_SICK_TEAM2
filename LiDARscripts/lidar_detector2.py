""" SICKSense Agripollinate LiDAR Detector Version 0.2 
    Created by:    Josiah Faircloth 
    date:    11/16/2025

    Detects and tracks object clusters from SICK TiM561 LiDAR scan data. Reads LiDAR 
    log files generated by LiDAR Logger Version 0.1. Triggers a signal whenever any
    new object appears that was not present before. Requires the object to be detected
    in multiple consecutive scans before triggering, and also triggers if a known object
    moves significantly from its original position.
"""

import json
import time
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN

# -------------------------------
# Configuration Parameters
# -------------------------------
SCAN_FILE = "lidar_log_11-14-2025_15.47.05.jsonl"  # LiDAR data file 
EPS = 0.3        # DBSCAN cluster distance threshold (meters) - minimum distance between points in a cluster
MIN_SAMPLES = 5   # minimum points per cluster
NEW_OBJ_DIST = 0.3  # meters: if a centroid is this far from all previous, treat as new
OBJECT_MEMORY_TIME = 0.5  # seconds: remember objects for this long after last seen
MIN_DETECTIONS = 5  # number of consecutive scans object must appear before triggering
MOVEMENT_THRESHOLD = 0.5  # meters: total movement to trigger even for known objects
DISPLAY = True

# -------------------------------
# Event Trigger Function
# -------------------------------
def on_new_object_detected(centroid, timestamp):
    """Called whenever a new cluster appears that wasn't present before."""

    print(f"[ALERT] New object detected at {centroid} at {timestamp:.2f}")

# -------------------------------
# Helper Functions
# -------------------------------
def polar_to_cartesian(ranges):
    """Convert polar ranges to (x, y) coordinates"""
    angles = np.linspace(-45, 225, len(ranges))
    x = ranges * np.cos(np.deg2rad(angles))
    y = ranges * np.sin(np.deg2rad(angles))
    return np.column_stack((x, y))

def detect_objects(points):
    """Cluster points using DBSCAN and return cluster centroids"""
    points = points[~np.isnan(points).any(axis=1)]
    if len(points) < MIN_SAMPLES:
        return []
    db = DBSCAN(eps=EPS, min_samples=MIN_SAMPLES).fit(points)
    labels = db.labels_
    centroids = []
    for lbl in np.unique(labels):
        if lbl == -1:  # noise
            continue
        cluster = points[labels == lbl]
        centroids.append(np.mean(cluster, axis=0))
    return np.array(centroids)


class ObjectTracker:
    """Tracks known objects over time with memory persistence and confirmation"""
    def __init__(self, memory_time=2.0, distance_threshold=0.4, min_detections=3, movement_threshold=0.5):
        self.confirmed_objects = []  # List of (centroid, last_seen_time, first_position)
        self.candidate_objects = []  # List of (centroid, first_seen_time, detection_count)
        self.memory_time = memory_time
        self.distance_threshold = distance_threshold
        self.min_detections = min_detections
        self.movement_threshold = movement_threshold
        self.first_scan = True
    
    def update(self, current_centroids, current_time):
        """Update tracker with new centroids, return list of NEW objects"""
        # On first scan, add all objects without triggering
        if self.first_scan:
            for centroid in current_centroids:
                self.confirmed_objects.append((centroid, current_time, centroid.copy()))
            self.first_scan = False
            return np.array([]).reshape(0, 2)
        
        # Clean up old confirmed objects
        self.confirmed_objects = [(pos, t, first_pos) for pos, t, first_pos in self.confirmed_objects 
                                  if current_time - t < self.memory_time]
        
        # Clean up old candidates
        self.candidate_objects = [(pos, first_t, count) for pos, first_t, count in self.candidate_objects 
                                  if current_time - first_t < self.memory_time]
        
        new_objects = []
        movement_objects = []
        matched_candidates = set()
        matched_confirmed = set()
        
        for centroid in current_centroids:
            matched_candidate = False
            matched_confirmed_obj = False
            
            # Check if matches a confirmed object
            for i, (known_pos, last_time, first_pos) in enumerate(self.confirmed_objects):
                dist = np.linalg.norm(centroid - known_pos)
                if dist < self.distance_threshold:
                    # Update position and time
                    self.confirmed_objects[i] = (centroid, current_time, first_pos)
                    matched_confirmed.add(i)
                    matched_confirmed_obj = True
                    
                    # Check for significant movement from original position
                    total_movement = np.linalg.norm(centroid - first_pos)
                    if total_movement > self.movement_threshold:
                        movement_objects.append(centroid)
                        # Reset first position to track next movement
                        self.confirmed_objects[i] = (centroid, current_time, centroid.copy())
                    break
                
            if matched_confirmed_obj:
                continue
            
            # Check if matches a candidate object
            for i, (cand_pos, first_t, count) in enumerate(self.candidate_objects):
                dist = np.linalg.norm(centroid - cand_pos)
                if dist < self.distance_threshold:
                    # Increment detection count
                    new_count = count + 1
                    if new_count >= self.min_detections:
                        # Promote to confirmed and trigger
                        new_objects.append(centroid)
                        self.confirmed_objects.append((centroid, current_time, centroid.copy()))
                        matched_candidates.add(i)
                    else:
                        # Update candidate
                        self.candidate_objects[i] = (centroid, first_t, new_count)
                        matched_candidates.add(i)
                    matched_candidate = True
                    break
            
            if not matched_candidate:
                # New candidate object (first detection)
                self.candidate_objects.append((centroid, current_time, 1))
        
        # Remove matched candidates that were promoted
        self.candidate_objects = [c for i, c in enumerate(self.candidate_objects) 
                                  if i not in matched_candidates or c[2] < self.min_detections]
        
        # Combine new objects and movement triggers
        all_triggers = new_objects + movement_objects
        
        if all_triggers:
            return np.array(all_triggers).reshape(-1, 2)
        else:
            return np.array([]).reshape(0, 2)

# -------------------------------
# Main Loop
# -------------------------------
def main():
    tracker = ObjectTracker(
        memory_time=OBJECT_MEMORY_TIME, 
        distance_threshold=NEW_OBJ_DIST,
        min_detections=MIN_DETECTIONS,
        movement_threshold=MOVEMENT_THRESHOLD
    )
    plt.ion()
    fig, ax = plt.subplots(figsize=(10, 10))
    object_count = 0

    with open(SCAN_FILE, 'r') as f:
        for line in f:
            try:
                scan = json.loads(line)
                ranges = np.array(scan["ranges"])
                ranges[(ranges < 0.005) | (ranges > 10)] = np.nan

                points = polar_to_cartesian(ranges)
                centroids = detect_objects(points)
                new_objects = tracker.update(centroids, scan["timestamp"])

                # Trigger event if new objects appear
                for c in new_objects:
                    on_new_object_detected(c, scan["timestamp"])
                    object_count += 1

                # Visualization
                if DISPLAY:
                    ax.clear()
                    ax.scatter(points[:, 0], points[:, 1], s=5, c='gray', label='Scan points')
                    if len(centroids) > 0:
                        ax.scatter(centroids[:, 0], centroids[:, 1], c='blue', s=40, label='Objects')
                    if len(new_objects) > 0:
                        ax.scatter(new_objects[:, 0], new_objects[:, 1], c='red', s=80, label='NEW')
                    ax.set_xlim(-7.5, 7.5)
                    ax.set_ylim(-7.5, 7.5)
                    ax.set_title("LiDAR Object Detection")
                    ax.legend(loc='upper right')
                    ax.set_aspect('equal')
                    plt.pause(0.01)
                time.sleep(0.05)
            except json.JSONDecodeError:
                continue

    plt.ioff()
    plt.show()
    print(f"Total objects detected: {object_count}")

if __name__ == "__main__":
    main()